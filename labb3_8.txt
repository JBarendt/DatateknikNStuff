.global process_switches
.text
.ent process_switches
process_switches:
	addi r1,r1,-4 ;Resaverar stackframe
	sw r15,r1,r0 ;Callback minne
	lwi r6,r0, 0x40020000 ;Läser switchar till r6
	add r5,r0,r0 ;Nollställ r5
	addi r7,r0,8 ;i i en i loop ish
	addi r10,r0,1 ;Bra med en 1a o så
shift: beqi r7, arg_ready ;När r7 är över 0 kör detta, annars hoppa till arg_ready
	nop 
	andi r9, r6,1 ;Kolla om LSB är 1 eller 0 lägg den i r9
	add r5,r5,r5 ;Dubble r5 efter varje call för binärt o så du vet
	add r5,r5,r9 ;Lägg in biten från r9
	sra r6,r6 ;Shifta 1 steg
	rsub r7,r10,r7 ; Gör detta 7  till gånger så har vi delat upp alla switchar 8 vänster i r6 och 8 höger i r5
	brid shift ;Hoppas till början av loopen
	nop
arg_ready: rsub r11,r5,r6 ;Ta höger - vänster lägg i r11
	bgei r11, moreThan ; Om r11 är possitiv lägg hoppa till moreThan
	blti r11, lessThan ; Annars stick till lessThan

moreThan: 
	addi r12, r0, -1 ; -1 = 0xFFFFFF så lägg det i r12
	swi r12,r0, 0x40010000 ;Lägg in 0xFFFFF hos lamporna så lyser dem fint
	rtsd r15,8 ;Avsluta subrutinen här så vi inte kör lessThan efteråt
	nop
	
lessThan:
	swi r0,r0, 0x40010000 ;Släck alla lampor
	rtsd r15,8 ; We're done lets go home
	nop
.end process_switches

------------------------------------------------------------

.global process_switches
.text
.ent process_switches
process_switches:
	addi r1,r1,-4 ;Stackframe på 4 bitar
	sw r15,r1,r0 ;Callback adress
	lwi r6,r0, 0x40020000 ;Läs in switcharna
	add r5,r0,r0 ;Lägg in en 0a i r5
	addi r7,r0,8 ; lägg in en 8a i r7
	addi r10,r0,1 ;1a i r10
	addi r11,r0,0x44A00000 ; Lagra adressen till displayerna
	add r8,r0,7 ; Lägg in en 7a i r8
	add r12,r0,r0 ; r12 vill vara 0

shift: beqi r7, arg_ready ;Medens r7 > 0, annars hoppa till arg_ready
	nop
	andi r9, r6,1 ;Kolla om LSB är 1 eller 0 lägg den i r9
	add r5,r5,r5 ;Dubble r5 efter varje call för binärt o så du vet
	add r5,r5,r9 ;Lägg in biten från r9
	sra r6,r6 ;Shifta 1 steg
	rsub r7,r10,r7 ; Gör detta 7  till gånger så har vi delat upp alla switchar 8 vänster i r6 och 8 höger i r5
	brid shift ;Hoppas till början av loopen
	nop
arg_ready: and r9,r6,r5 ;Anda höger o vänster så får vi om de är samma, r9 blir resultatet av anden
display: add r18,r8,r8 ;Mega hax för hoppa 4 bitar per iteration part 1/2 (4 bitar för ny display)
	add r18, r18, r18  ;Mega hax för hoppa 4 bitar per iteration part 2/2
	andi r12,r9,1 ;Kolla om LSB är 1 eller 0, lägg in resultatet i r12
	sra r9,r9 ;Shifta r9 1 steg så vi kan kolla nästa bit
	lwi r13, r12, display_codes ;Hämta antingen 1 eller 0 beroende på vad vi fick
	sw  r13, r11, r18 ; Visa den på displayen, (minskar med 1 display varje gång aka 4 bitar)
	rsub r8, r10, r8 ;Ta bort 1 från r8
	bgeid display ; Hoppa tillbaka i loopen om r8 är större än 0 så vi får alla displayer/bitar
	rtsd r15,8 ; Stick tillbaka från subrutinen
	nop
.end process_switches

---------------------------------------------------


.global function
.text
.ent function
function:
	addi r1,r1,-4 ; Stack frame
	swi r15,r1,0 ; Callback adress
	addi r6,r0,0x44A00000 ; Lägg adressen till 1a displayen i r6
	addi r8, 10 ; sätt r8 till 10
	addi r9, 0 ;sätt r9 till 0 
	
	lwi r5,r0, 0x40020000 ;Läs in switcharna
	brlid r15, number_of_ones ; Räkna ut antalet 1or (lägger in i r3)
	rsub r7, r8, r3 ;Antalet 1orn - 10 ger oss possitivt om fler än 10 switchar eller - om lägre
	bgei r7, ABOVETEN ;Om det är 10 eller fler hoppa till ABOVETEN
	blti r7, LESSTHANTEN ;Annars till LESSTHANTEN
	
	
ABOVETEN:
	lwi r13, r7, display_codes ; Hämta 2a siffran, ex 12-10 = 2 hämta 2
	sw r13, r0, r6 ;Sätt displayen till r7
	addi r6,r6,4 ;Lägg till 4 bitar för vi ska till nästa display
	addi r7, r0, 1 ; efter som vi max har 16 så sätter vi display 2 till 1
	lwi r13, r7, display_codes ; Hämta 1a
	sw r13, r0, r6 ;Displaya 1an på display 2
	rtsd r15,8 ;Avsluta rutin
LESSTHANTEN:
	lwi r13, r3, display_codes ;Hämta siffran
	sw r13, r0, r6 ; Visa den på dispalyen
	rtsd r15,8 ; Stick tbx
	
.end function







